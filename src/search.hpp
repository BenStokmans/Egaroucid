#pragma once
#include <iostream>
#include <fstream>
#include <math.h>
#include "setting.hpp"
#include "common.hpp"
#include "board.hpp"
#include "evaluate.hpp"
#include "transpose_table.hpp"

using namespace std;

#define search_epsilon 1
constexpr int cache_hit = 100;
constexpr int cache_both = 100;
constexpr int parity_vacant_bonus = 10;
constexpr int canput_bonus = 0;

#define mpc_min_depth 3
#define mpc_max_depth 25
#define mpc_min_depth_final 9
#define mpc_max_depth_final 30

#define simple_mid_threshold 3
#define simple_end_threshold 7

#define po_max_depth 8

#define extra_stability_threshold 58

const int cell_weight[hw2] = {
    10, 3, 9, 7, 7, 9, 3, 10, 
    3, 2, 4, 5, 5, 4, 2, 3, 
    9, 4, 8, 6, 6, 8, 4, 9, 
    7, 5, 6, 0, 0, 6, 5, 7, 
    7, 5, 6, 0, 0, 6, 5, 7, 
    9, 4, 8, 6, 6, 8, 4, 9, 
    3, 2, 4, 5, 5, 4, 2, 3, 
    10, 3, 9, 7, 7, 9, 3, 10
};

const int mpcd[32] = {0, 1, 0, 1, 2, 3, 2, 3, 4, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 8, 9};
#if USE_MID_SMOOTH
    double mpcsd[n_phases][mpc_max_depth - mpc_min_depth + 1]={
        {0.443, 0.392, 0.574, 1.041, 1.015, 0.996, 1.618, 1.392, 1.729, 1.657, 1.063, 0.914, 0.884, 0.828, 1.031, 0.765, 0.865, 0.945, 0.288, 0.475, 0.628, 0.402, 0.945},
        {1.207, 0.613, 1.286, 1.122, 0.995, 1.396, 1.323, 1.717, 1.865, 1.443, 1.4, 1.689, 1.189, 1.319, 1.21, 1.387, 1.553, 1.915, 0.638, 0.508, 0.844, 0.75, 1.51},
        {1.763, 1.068, 1.675, 2.494, 1.551, 1.701, 2.019, 2.126, 1.998, 1.942, 1.533, 2.398, 1.325, 1.559, 1.742, 1.486, 1.362, 1.777, 0.731, 0.761, 0.777, 0.834, 1.455},
        {2.315, 2.51, 1.362, 2.501, 2.023, 1.908, 2.368, 1.723, 1.731, 1.5, 2.063, 2.013, 1.468, 1.414, 1.716, 1.263, 1.64, 2.058, 0.823, 0.935, 0.937, 1.188, 1.564},
        {1.828, 2.245, 2.285, 2.188, 2.036, 1.773, 2.52, 1.754, 2.423, 2.304, 1.61, 2.284, 1.966, 1.579, 1.769, 1.831, 1.601, 2.872, 0.735, 1.223, 1.041, 0.961, 1.085},
        {1.622, 1.905, 2.069, 2.541, 2.502, 2.758, 1.965, 2.165, 2.168, 2.242, 1.765, 3.238, 1.998, 1.698, 2.361, 2.145, 1.369, 2.043, 1.014, 0.951, 1.052, 1.291, 1.312},
        {3.457, 3.163, 2.212, 4.104, 1.877, 1.281, 2.374, 3.49, 2.863, 2.601, 2.27, 2.09, 1.914, 1.877, 2.042, 2.193, 2.398, 1.725, 0.704, 1.203, 1.684, 0.895, 3.12},
        {2.374, 1.605, 1.733, 3.568, 2.218, 2.507, 2.636, 2.8, 2.566, 3.109, 2.189, 2.674, 1.74, 2.612, 3.694, 2.541, 2.109, 2.409, 1.033, 1.29, 2.212, 1.015, 1.991},
        {2.566, 3.058, 2.06, 3.963, 1.91, 2.18, 3.189, 2.231, 3.162, 3.121, 2.986, 3.294, 2.755, 2.399, 2.714, 2.074, 1.759, 2.18, 1.098, 1.113, 1.284, 1.5, 1.676},
        {2.915, 2.604, 2.499, 3.432, 3.142, 2.09, 3.236, 4.002, 3.213, 2.779, 2.614, 2.565, 2.302, 2.502, 2.664, 2.088, 3.092, 3.007, 1.188, 1.77, 1.316, 1.553, 1.84},
        {3.214, 2.612, 2.253, 2.772, 2.765, 2.658, 3.472, 3.397, 3.477, 2.515, 2.483, 3.371, 2.589, 2.638, 3.433, 2.41, 2.694, 2.907, 0.935, 1.482, 2.135, 1.752, 1.9},
        {2.151, 2.594, 2.738, 3.81, 2.978, 2.707, 4.436, 4.537, 3.868, 3.936, 3.523, 4.897, 3.552, 3.298, 3.694, 3.212, 3.95, 3.414, 0.993, 1.679, 1.704, 1.615, 2.7},
        {2.413, 3.151, 2.794, 4.462, 4.564, 3.647, 4.345, 4.674, 4.355, 4.115, 3.643, 4.611, 3.378, 2.808, 3.148, 2.92, 2.707, 2.448, 1.795, 1.386, 1.622, 1.032, 2.208},
        {3.373, 2.858, 3.029, 3.872, 4.27, 2.447, 3.352, 2.95, 3.571, 2.082, 2.449, 3.035, 1.674, 1.586, 2.883, 1.878, 0.881, 1.406, 1.414, 1.817, 0.641, 1.828, 1.725},
        {2.08, 2.212, 0.655, 1.685, 1.192, 0.213, 0.909, 0.348, 0.643, 0.507, 0.4, 0.343, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    };
    double mpcsd_final[mpc_max_depth_final - mpc_min_depth_final + 1] = {
        4.963, 4.686, 5.166, 4.945, 4.881, 5.067, 4.82, 4.666, 4.894, 4.665, 4.626, 4.662, 4.567, 4.525, 4.493, 4.261, 4.267, 4.151, 4.166, 4.144, 4.276, 4.437
    };
#else
    double mpcsd[n_phases][mpc_max_depth - mpc_min_depth + 1]={
        {1.414, 0.849, 0.908, 0.655, 0.82, 1.041, 1.225, 1.0, 0.766, 0.745, 0.507, 0.943, 1.1, 0.838, 0.0, 0.186, 0.418, 0.819, 0.572, 0.458, 0.504, 0.483, 0.586},
        {1.183, 0.905, 0.929, 1.532, 1.32, 0.978, 1.183, 1.2, 0.87, 0.95, 0.86, 1.3, 1.113, 0.847, 0.871, 0.463, 1.008, 1.361, 0.454, 0.61, 0.673, 1.164, 1.366},
        {2.57, 1.16, 1.433, 2.61, 2.615, 2.411, 1.795, 1.823, 1.293, 1.581, 1.633, 1.356, 1.185, 0.845, 1.254, 0.869, 0.921, 2.137, 0.692, 0.797, 0.955, 1.293, 1.366},
        {2.751, 2.613, 1.749, 1.806, 2.045, 1.459, 1.694, 1.821, 1.806, 1.796, 1.496, 1.316, 1.641, 0.647, 1.091, 1.018, 1.044, 1.283, 0.727, 0.819, 1.491, 1.231, 1.414},
        {3.124, 2.551, 1.718, 2.362, 2.849, 1.033, 2.308, 1.759, 1.921, 1.915, 1.51, 1.899, 1.525, 0.728, 1.359, 1.39, 1.406, 2.221, 0.59, 0.793, 1.073, 1.305, 1.258},
        {1.225, 1.981, 2.449, 2.06, 2.712, 2.233, 2.314, 3.516, 2.01, 2.072, 1.46, 2.056, 2.027, 2.223, 1.391, 1.37, 1.301, 1.608, 1.079, 0.921, 1.673, 0.802, 1.445},
        {2.463, 2.404, 2.521, 2.366, 2.551, 2.243, 3.024, 1.815, 1.917, 1.426, 1.69, 2.145, 1.763, 0.859, 0.954, 1.393, 1.334, 1.829, 0.649, 0.775, 1.179, 1.422, 1.499},
        {1.593, 1.457, 1.505, 2.644, 2.032, 2.406, 2.782, 3.247, 2.111, 1.816, 2.189, 2.374, 2.591, 0.893, 1.641, 1.224, 1.224, 2.559, 0.994, 0.779, 0.948, 1.697, 1.614},
        {2.29, 2.906, 1.929, 3.072, 2.438, 2.463, 2.689, 3.754, 3.041, 2.384, 1.223, 1.81, 2.479, 0.833, 1.621, 1.295, 1.248, 2.093, 0.702, 1.254, 1.434, 1.315, 2.286},
        {4.161, 0.843, 2.166, 4.259, 3.289, 2.575, 3.414, 3.43, 2.288, 2.54, 2.755, 2.817, 2.504, 0.795, 1.541, 1.575, 2.177, 3.516, 0.976, 1.543, 1.272, 1.542, 2.057},
        {2.898, 2.408, 2.453, 4.039, 2.722, 2.568, 4.551, 4.081, 3.905, 2.628, 2.833, 4.193, 2.209, 1.495, 2.0, 1.528, 1.706, 2.662, 0.994, 1.601, 1.218, 1.384, 1.834},
        {3.005, 3.078, 2.434, 4.243, 3.133, 4.262, 5.787, 4.689, 3.444, 3.766, 2.643, 4.498, 4.048, 1.386, 2.061, 2.068, 2.758, 2.39, 1.121, 1.581, 1.261, 1.417, 2.667},
        {3.528, 2.897, 2.617, 4.674, 3.092, 5.272, 6.154, 5.471, 3.594, 3.934, 2.264, 5.074, 4.368, 1.361, 1.953, 1.956, 2.078, 3.144, 1.337, 1.42, 1.739, 1.103, 2.514},
        {3.407, 4.47, 3.207, 4.782, 3.768, 2.371, 3.592, 3.744, 3.345, 3.215, 1.62, 3.328, 2.034, 0.724, 1.699, 0.861, 0.884, 1.282, 1.906, 1.022, 1.405, 2.689, 1.048},
        {2.151, 2.321, 0.985, 1.613, 0.539, 0.6, 0.745, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6}
    };
    double mpcsd_final[mpc_max_depth_final - mpc_min_depth_final + 1] = {
        4.957, 4.665, 5.19, 4.926, 4.836, 4.952, 4.677, 4.489, 4.874, 4.59, 4.551, 4.392, 4.353, 4.513, 4.483, 4.288, 4.189, 4.042, 4.09, 4.125, 4.128, 4.267
    };
#endif
unsigned long long can_be_flipped[hw2];

unsigned long long searched_nodes;
vector<int> vacant_lst;

struct search_result{
    int policy;
    int value;
    int depth;
    int nps;
};

inline void search_init(){
    int i;
    for (int cell = 0; cell < hw2; ++cell){
        can_be_flipped[cell] = 0b1111111110000001100000011000000110000001100000011000000111111111;
        for (i = 0; i < hw; ++i){
            if (global_place[place_included[cell][0]][i] != -1)
                can_be_flipped[cell] |= 1ULL << global_place[place_included[cell][0]][i];
        }
        for (i = 0; i < hw; ++i){
            if (global_place[place_included[cell][1]][i] != -1)
                can_be_flipped[cell] |= 1ULL << global_place[place_included[cell][1]][i];
        }
        for (i = 0; i < hw; ++i){
            if (global_place[place_included[cell][2]][i] != -1)
                can_be_flipped[cell] |= 1ULL << global_place[place_included[cell][2]][i];
        }
        if (place_included[cell][3] != -1){
            for (i = 0; i < hw; ++i){
                if (global_place[place_included[cell][3]][i] != -1)
                    can_be_flipped[cell] |= 1ULL << global_place[place_included[cell][3]][i];
            }
        }
    }
    cerr << "search initialized" << endl;
}

int cmp_vacant(int p, int q){
    return cell_weight[p] > cell_weight[q];
}

inline void move_ordering(board *b){
    int l, u;
    transpose_table.get_prev(b, b->hash() & search_hash_mask, &l, &u);
    if (u != inf && l != -inf)
        b->v = -(u + l) / 2 + cache_hit + cache_both;
    else if (u != inf)
        b->v = -mid_evaluate(b) + cache_hit;
    else if (l != -inf)
        b->v = -mid_evaluate(b) + cache_hit;
    else
        b->v = -mid_evaluate(b);
}

inline void move_ordering_eval(board *b){
    b->v = -mid_evaluate(b);
}

inline void calc_extra_stability(board *b, int p, unsigned long long extra_stability, int *pres, int *ores){
    *pres = 0;
    *ores = 0;
    int y, x;
    extra_stability >>= hw;
    for (y = 1; y < hw_m1; ++y){
        extra_stability >>= 1;
        for (x = 1; x < hw_m1; ++x){
            if ((extra_stability & 1) == 0){
                if (pop_digit[b->b[y]][x] == p)
                    ++*pres;
                else if (pop_digit[b->b[y]][x] == 1 - p)
                    ++*ores;
            }
            extra_stability >>= 1;
        }
        extra_stability >>= 1;
    }
}

inline unsigned long long calc_extra_stability_ull(board *b){
    unsigned long long extra_stability = 0b1111111110000001100000011000000110000001100000011000000111111111;
    for (const int &cell: vacant_lst){
        if (pop_digit[b->b[cell / hw]][cell % hw] == vacant)
            extra_stability |= can_be_flipped[cell];
    }
    return extra_stability;
}

inline bool stability_cut(board *b, int *alpha, int *beta){
    if (b->n >= extra_stability_threshold){
        int ps, os;
        calc_extra_stability(b, b->p, calc_extra_stability_ull(b), &ps, &os);
        *alpha = max(*alpha, (2 * (calc_stability(b, b->p) + ps) - hw2));
        *beta = min(*beta, (hw2 - 2 * (calc_stability(b, 1 - b->p) + os)));
    } else{
        *alpha = max(*alpha, (2 * calc_stability(b, b->p) - hw2));
        *beta = min(*beta, (hw2 - 2 * calc_stability(b, 1 - b->p)));
    }
    return *alpha >= *beta;
}

inline int calc_canput_exact(board *b){
    int res = 0;
    for (const int &cell: vacant_lst)
        res += b->legal(cell);
    return res;
}
